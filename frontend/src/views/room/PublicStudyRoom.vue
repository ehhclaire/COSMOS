<template>
	<div id="main">
		<div id="main-container" class="d-flex">
			<p>
				<img v-if="!asideRight" src="@/assets/img/openvidu/menu.png" class="rightMenuImg" alt="menu" @click="asideRight=true">
				<img v-else src="@/assets/img/openvidu/close.png" class="rightMenuImg" alt="menu" @click="asideRight=false">
			</p>
			<div id="session-aside-left" v-if="session">
				<p><img src="@/assets/img/openvidu/asideimg01.png" class="sideMenuImg" alt="settings" @click="outMemberModal=true"></p>

				<!-- Í∞ïÌá¥Í∏∞Îä• Î™®Îã¨ -->
				<div v-if="outMemberModal" class="black-bg">
					<div class="white-bg">
						<h2>Î©§Î≤Ñ</h2>
						<hr>						
						<table class="table table-bordered table-hover align-middle">
							<thead class="table-danger">
								<tr>
									<th>Ïù¥Î¶Ñ(ID)</th>
									<th>Í∞ïÌá¥</th>
								</tr>
							</thead>
							<tbody v-for="member in publicStudyMembers" :key="member.id">
								<tr>
								<td>{{member.user.userName}}({{member.user.userId}})</td>
								<td><b-button v-if="member.user.userId!==userId && isLeader" variant="danger" @click="outMember(member.user.userId, member.id)">Í∞ïÌá¥</b-button></td>
								<!-- <td><b-button v-if="member.user.userId!==userId && isLeader" variant="danger" @click="outMember(member.id)">Í∞ïÌá¥</b-button></td> -->
								</tr>
							</tbody>
						</table>
						<div class="d-flex justify-content-end">
							<button @click="outMemberModal=false" class="btn btn-secondary">Îã´Í∏∞</button>
						</div>
					</div>
				</div>

			</div>
			<div id="session-center">
				<div id="session" v-if="session">
					<div id="session-header" class="d-flex">
						<h1 id="session-title">{{ this.roomName }}</h1> <!-- Î∞© Ï†úÎ™© -->
					</div>
					
					<div>
						<!-- <div id="main-video" class="col-md-6">
							<user-video :stream-manager="mainStreamManager"/>
						</div> -->
						<div id="video-container" class="d-flex flex-wrap row"> <!-- Ï∞∏Í∞ÄÏûê ÌôîÎ©¥ -->
							<user-video class="col-md-4" v-if="!isScreenShared" :stream-manager= "publisher" @click.native="updateMainVideoStreamManager(publisher)"/> <!--ÏûêÍ∏∞ -->
							<user-video class="col-md-4" v-for="sub in subscribers" :key="sub.stream.connection.connectionId" :stream-manager="sub" @click.native="updateMainVideoStreamManager(sub)"/> <!-- Îã§Î•∏ Ï∞∏Í∞ÄÏûê -->
						</div>
						
					</div>
				</div>

				<div id="session-footer-wrap" class="d-flex justify-content-center">
					<div id="session-footer" v-if="session">
						<div class="session-footer_btn d-flex justify-content-center">
							<!-- microphone Î≤ÑÌäº ÏÑ§Ï†ï -->
							<div v-if="audio === true" class="buttomMenu">
								
								<button class="btn btn-large btn-default footerBtn" type="button" id="buttonLeaveSession" @click="muteAudio()">
									<b-icon icon="mic-fill" class="buttomMenuIcon" aria-hidden="true"></b-icon>
									<span class="footerBtnText">{{ audioMsg }}</span>
								</button> <!-- ÎßàÏù¥ÌÅ¨ on/off Î≤ÑÌäº -->
							</div>
							<div v-else class="roomFun buttomMenu">
								<button class="btn btn-large btn-default footerBtn" type="button" id="buttonLeaveSession" @click="muteAudio()">
									<b-icon icon="mic-mute-fill" class="buttomMenuIcon" aria-hidden="true"></b-icon>
									<span class="footerBtnText">{{ audioMsg }}</span>
								</button><!-- ÎßàÏù¥ÌÅ¨ on/off Î≤ÑÌäº -->
							</div>	

							<!-- video Î≤ÑÌäº ÏÑ§Ï†ï -->
							<div v-if="video === true" class="buttomMenu">
								<!-- <input class="btn btn-large btn-default footerBtn" type="button" id="buttonLeaveSession" :value="video" @click="muteVideo()"> ÎπÑÎîîÏò§ on/off Î≤ÑÌäº -->
								<button class="btn btn-large btn-default footerBtn" type="button" id="buttonLeaveSession" @click="muteVideo()"> 
									<b-icon icon="camera-video-fill" class="buttomMenuIcon" aria-hidden="true"></b-icon>
									<span class="footerBtnText">{{ videoMsg }}</span>
								</button>
							</div>
							<div v-else class="roomFun buttomMenu">
								<button class="btn btn-large btn-default footerBtn" type="button" id="buttonLeaveSession" @click="muteVideo()"> 
									<b-icon icon="camera-video-off-fill" class="buttomMenuIcon" aria-hidden="true"></b-icon>
									<span class="footerBtnText">{{ videoMsg }}</span>
								</button>
							</div>

							<!-- ÎÇòÍ∞ÄÍ∏∞ Î≤ÑÌäº ÏÑ§Ï†ï -->
							<div class="buttomMenu">
								<button class="btn btn-large btn-default footerBtn" type="button" id="buttonLeaveSession" @click="leaveSession">
									<b-icon icon="door-open-fill" class="buttomMenuIcon" aria-hidden="true"></b-icon>
									<span class="footerBtnText">ÎÇòÍ∞ÄÍ∏∞</span>
								</button> <!-- ÎÇòÍ∞ÄÍ∏∞ Î≤ÑÌäº -->
							</div>
						</div>	
					</div>
				</div> <!-- #session-footer-wrap -->
			</div> <!-- #session-center -->
			<div id="session-aside-right" v-if="session && asideRight">
				<div class="participant">
					<div class="right_label">
						<span>Ï∞∏Í∞ÄÏûê</span>
					</div>
					<div class="participant_list"> <!-- Ï∞∏Í∞ÄÏûê Î¶¨Ïä§Ìä∏ ÌôîÎ©¥ -->
						<user-list :stream-manager="publisher"/>
						<user-list v-for="sub in subscribers" :key="sub.stream.connection.connectionId" :stream-manager="sub"/>
					</div>
				</div>

				<!-- Ï±ÑÌåÖ Í∏∞Îä• ÏãúÏûë -->
				<!-- <p @click="showChat">Ï±ÑÌåÖ</p> -->
					<!-- <div class="chat" v-show="isChatVisible"> -->
				<div class="user_chat">
					<div class="right_label">
						<span>Ï±ÑÌåÖ</span>
					</div>
					<div class="chat">
						<div class="messages" v-html="messages" ref="messages">
							<!-- <div class="messageLoop" v-for="(message, idx) in messages" :key="idx"> -->
								<!-- <div class="text-left" >{{ userId }} ÎãòÏùò Î©îÏãúÏßÄ:</div> -->
								<!-- <div class="text-left message__bubble">{{ message }}</div> -->
							<!-- </div> -->
						</div>

						<form class="chatFooter" onsubmit="return false">
							<input class="chat_input" id="msg" type="text" autocomplete="off" placeholder="Î©îÏÑ∏ÏßÄÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.">
							<button id="submitBtn" type="submit" @click="sendMessage()">Enter</button>
						</form>
					</div>
				</div>
				<!-- Ï±ÑÌåÖ Í∏∞Îä• ÎÅù -->
			</div> <!-- session-right -->
		</div> <!-- #main-container -->
		
	</div>
</template>
<style scoped>

</style>
<script>
import "@/assets/style/style.css";
import "@/assets/style/PrivateStudyRoom/room.css"
import axios from 'axios';
import http from "@/util/http-common.js";
import { OpenVidu } from 'openvidu-browser';
import UserVideo from '@/components/openvidu/PublicUserVideo';
import UserList from '@/components/openvidu/UserList';
import jwt_decode from "jwt-decode";

import { mapState } from "vuex";

axios.defaults.headers.post['Content-Type'] = 'application/json';

const OPENVIDU_SERVER_URL = "https://i6e103.p.ssafy.io:8084";
const OPENVIDU_SERVER_SECRET = "ssafy1234";

export default {
	name: 'App',

	components: {
		UserVideo,
		UserList,
	},
	metaInfo: {
		// title ÏûÖÎ†•ÌïòÍ∏∞
		title: 'COSMOS',
		// link tag ÏûÖÎ†•ÌïòÍ∏∞
		link: [{rel: "stylesheet", href: 'https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css'}],
		// meta tag ÏûÖÎ†•ÌïòÍ∏∞
		meta: [
		{ charset: 'utf-8' },
		{ name: 'viewport', content: 'width=device-width, initial-scale=1' },
		{ vmid: "description", name: "description", content: 'description' }
		//vmid ‚Üë Î©îÌÉÄ ÌÉúÍ∑∏Î•º Í≥†Ïú†ÌïòÍ≤å ÎßåÎì§Ïñ¥Ï§ÄÎã§.
		]
  },
	data () {
		return {
			// ÌôîÎ©¥ Í≥µÏú†
			// OVForScreenShare: undefined,
			// sessionForScreenShare: undefined,
			sharingPublisher: undefined,
			sharing:true,
			OV: undefined,
			session: undefined,
			mainStreamManager: undefined,
			publisher: undefined,
			subscribers: [],
			mySessionId: null,
			myUserName: null,
			audioEnabled: true,
			videoEnabled: true,
			audio: true,
			video: true,
			audioMsg: 'ÎßàÏù¥ÌÅ¨ ON',
			videoMsg: 'ÎπÑÎîîÏò§ ON',
			messages: '',
			userId: '',
			isChatVisible: false,


			// ÌÉÄÏù¥Î®∏
			timer: null,
			time: 0,

			// Í∂åÌïú Ïó¨Î∂Ä
			userAuthority: false,
			
			// Í≥µÍ∞úÏä§ÌÑ∞Îîî Ï∞∏Í∞ÄÏûê Î™©Î°ù
			publicStudyMembers: [],

			// Í∞ïÌá¥Í¥ÄÎ†®
			outMemberModal: false,
			isLeader: null,

			// Ïò§Î•∏Ï™Ω ÏÇ¨Ïù¥Îìú Î©îÎâ¥
			asideRight: false,
		}
	},
	computed:{
		...mapState(["roomName", "roomUrl", "participant", "roomStudyNo"]),
	},
	created(){
		// Í∂åÌïú Ïó¨Î∂Ä ÌôïÏù∏
		http({
            method: 'GET',
            url: `/user/leader`,
            headers: this.getUserToken(),
			params: {study_no: this.roomStudyNo},
			// params: {study_no: 25},
          })
        .then((res) => {
            this.userAuthority = res.data.authority;
			// console.log("üòâüòâ")
			// console.log(res);
          })
          .catch(err => {
            console.log(err)
		});  

		this.mySessionId = this.roomUrl;
		this.myUserName = this.participant;
		this.joinSession();
		
		console.log("üòÄüòÄüòÄüòÄüòÄ")
		console.log(this.myUserName)

		// ÌÖçÏä§Ìä∏ Ï±ÑÌåÖÏóêÏÑú ÏÇ¨Ïö©ÌïòÍ∏∞ÏúÑÌïú Ïú†Ï†Ä ÏïÑÏù¥Îîî(ÏûÑÏãú)
		this.userId = jwt_decode(localStorage.getItem("jwt")).sub;
		console.log(">>>>>>>>>>>>>>>>>>>> userId : ", this.userId);

		// Í∞ïÌá¥Í∏∞Îä•ÏúÑÌï¥ Í≥µÍ∞úÏä§ÌÑ∞ÎîîÎ©§Î≤Ñ Î∂àÎü¨Ïò§Í∏∞
		this.getPublicStudyMembers(this.roomUrl)
		console.log(this.roomUrl)
		this.getLeave()

		
	},
	methods: {
		getUserToken(){
			const token = localStorage.getItem('jwt')
			const header = {
				Authorization: `Bearer ${token}`
			}
			return header
		},

		getToken_info(){
			const token = localStorage.getItem('jwt')
			const header = {
				Authorization: `Bearer ${token}`
			}
      return header
		},

		// Í≥µÍ∞úÏä§ÌÑ∞Îîî Î©§Î≤Ñ Î∂àÎü¨Ïò§Í∏∞
		getPublicStudyMembers(publicstudyroomid) {
      http({
        method: 'GET',
        url: '/publicroom/search/publicMember',
        params: { publicstudyroom_id: publicstudyroomid }
      })
      .then(res => {
        console.log(res)
				this.publicStudyMembers = res.data
				this.publicStudyMembers.forEach(element => {
					if (this.userId === element.user.userId){
						if (element.leader){
							this.isLeader = true
						}
					}
				})
      })
      .catch(err => {
        console.log(err)
      })
		},
		// Î©§Î≤Ñ Í∞ïÌá¥ÌïòÍ∏∞(user_id,publicstudyroom_id)
		// outMember(memberId, idx) {
		outMember(idx) {
			// http({
			// 	method: 'DELETE',
			// 	url:'publicroom/remove/publicMember',
			// 	params: {user_id: memberId, publicstudyroom_id: this.roomUrl}
			// })
			// .then(res => {
			// 	console.log(res)
			// 	const data = {
			// 		leave: true,
			// 	};
			// 	this.publisher.session.signal({
      //   data: JSON.stringify(data),
      //   to: [this.this.subscribers[idx].stream.connection],
      //   type: "kick",
      // });
			// })
			// .catch(err => {
			// 	console.log(err)
			// })
			const data = {
					leave: true,
				};
				this.publisher.session.signal({
        data: JSON.stringify(data),
        to: [this.this.subscribers[idx].stream.connection],
        type: "kick",
				})
    },
    getLeave() {
      this.session.on("signal:kick", () => {
        this.leaveSession();
      });
    },
		
		joinSession () {
			// --- Get an OpenVidu object ---
			this.OV = new OpenVidu();

			// --- Init a session ---
			this.session = this.OV.initSession();
		
			// --- Specify the actions when events take place in the session ---

			// On every new Stream received...
			this.session.on('streamCreated', ({ stream }) => {
				const subscriber = this.session.subscribe(stream);
				this.subscribers.push(subscriber);
				this.getPublicStudyMembers()
			});

			// On every Stream destroyed...
			this.session.on('streamDestroyed', ({ stream }) => {
				const index = this.subscribers.indexOf(stream.streamManager, 0);
				if (index >= 0) {
					this.subscribers.splice(index, 1);
				}
			});

			// On every asynchronous exception...
			this.session.on('exception', ({ exception }) => {
				console.warn(exception);
			});

			// Í∞ôÏùÄ session ÎÇ¥ÏóêÏÑú ÌÖçÏä§Ìä∏ Ï±ÑÌåÖÏùÑ ÏúÑÌïú signal
			this.session.on('signal:my-chat', (event) => {
				var message = event.data.split("&$");
				console.log(">>>>>>>>>>>>>> message : ", message);

				if(message == "") {
					this.messages += '';
				} else {
					// console.log(">>>>>>>>>>>>>>>>>>> ", message[0]);
					// this.messages.push(message[0]);
					console.log("Ï†ÄÏû•Îêú : ", this.$store.state.userId, "ÌòÑÏû¨ : ", message[0]);
					if(this.$store.state.userId == message[0]) {
						console.log("ÎÇ¥Í∞Ä Ïì¥ Î©îÏãúÏßÄ");
						this.messages += '<div align="right">' 
										+ 	'<div style="padding: 10px; margin-bottom: 10px; width: 60%; background-color: #fff; border-radius: 10px;  word-wrap: break-word;"">'
										+  		'<div style="font-weight: 900;">' + message[0] + ' ÎãòÏùò Î©îÏãúÏßÄ: </div>'
										+  		'<div class="mb-3">' + message[1] + ' </div>'
										+  	'</div>'
										+ '</div>';
					} else {
						console.log('ÎãàÍ∞Ä Ïì¥ Î©îÏãúÏßÄ');
						this.messages += '<div align="left">' 
										+ 	'<div style="padding: 10px; margin-bottom: 10px; width: 60%; background-color: #6363bf; color: #fff; border-radius: 10px;  word-wrap: break-word;"">'
										+  	'<div style="font-weight: 900;">' + message[0] + ' ÎãòÏùò Î©îÏãúÏßÄ: </div>'
										+  	'<div class="mb-3">' + message[1] + ' </div>'
										+  '</div>';
					}
				}
			});
		
			// --- Connect to the session with a valid user token ---

			// 'getToken' method is simulating what your server-side should do.
			// 'token' parameter should be retrieved and returned by your own backend
			this.getToken(this.mySessionId).then(token => {
				this.session.connect(token, { clientData: this.myUserName })
					.then(() => {

						// --- Get your own camera stream with the desired properties ---
						// console.log("Dasdasdasdasdasdasdasdasdasdasdasdasdqwrqwrqw");
						// console.log(this.session)
						let publisher = this.OV.initPublisher(undefined, {
							audioSource: undefined, // The source of audio. If undefined default microphone
							videoSource: undefined, // The source of video. If undefined default webcam
							publishAudio: true,  	// Whether you want to start publishing with your audio unmuted or not
							publishVideo: true,  	// Whether you want to start publishing with your video enabled or not
							resolution: '640x480',  // The resolution of your video
							frameRate: 30,			// The frame rate of your video
							insertMode: 'APPEND',	// How the video is inserted in the target element 'video-container'
							mirror: false,       	// Whether to mirror your local video or not
						});

						this.mainStreamManager = publisher;
						this.publisher = publisher;

						// --- Publish your stream ---

						this.session.publish(this.publisher);
						console.log("Dasdasdasdasdasdasdasdasdasdasdasdasdqwrqwrqw");
						console.log(this.session)
					})
					.catch(error => {
						console.log('There was an error connecting to the session:', error.code, error.message);
					});
			});
			
			// ÌÉÄÏù¥Î®∏ receive
			// this.session.on('signal:study-timer', (event) => {				
			// 	this.time = Number(event.data);
			// })

			window.addEventListener('beforeunload', this.leaveSession)
		},
		async removePublicRoom(){
			await http({
				method: 'DELETE',
				url: '/publicroom/remove/publicRoom',				
				params: {publicstudyroom_id: this.mySessionId},
			})
			.then(() => {
				
			})
			.catch(err => {
				console.log(err)
			});
		},

		leaveSession () {
			// --- Leave the session by calling 'disconnect' method over the Session object ---
			if (this.session) this.session.disconnect();

			this.session = undefined;
			this.mainStreamManager = undefined;
			this.publisher = undefined;
			this.subscribers = [];
			this.OV = undefined;
			this.OVForScreenShare = undefined;
			this.sharingPublisher = undefined;
			window.removeEventListener('beforeunload', this.leaveSession);
			http({
				method: 'DELETE',
				url: '/publicroom/remove/publicMember',
				headers: this.getToken_info(),
				params: {user_id: this.userId, publicstudyroom_id: this.mySessionId},
			})
			.then(() => {
				this.removePublicRoom()
				this.$router.push({name:'MainPage'})
			})
			.catch(err => {
				console.log(err)
			});


			
			this.sharing = !this.sharing;
			if (this.sessionForScreenShare) this.sessionForScreenShare.disconnect();
            this.sessionForScreenShare = undefined;
            this.mainStreamManager = undefined;
            this.sharingPublisher = undefined;
            this.OVForScreenShare = undefined;
            window.removeEventListener('beforeunload', this.leaveSessionForScreenSharing);
		},

		// ÌÖçÏä§Ìä∏ Ï±ÑÌåÖÏùÑ ÏúÑÌïú Î©îÏÑ∏ÏßÄ Ï†ÑÏÜ°ÌïòÍ∏∞
		sendMessage() {
			var message = document.getElementById("msg").value;
			if(message != "") {
				console.log("message " , message)
				
				
				this.session.signal({
					data: this.myUserName+ "&$" +message,
					to: [],
					type: 'my-chat',
				})
				.then(() => {
					console.log("message sent successfully!!");
					document.getElementById("msg").value = "";
				})
				.catch(error => {
					console.error(error);
				})
			}
		},

		muteVideo() {
			this.videoEnabled = !this.videoEnabled;
			this.video = !this.video;
			if(this.video == true) this.videoMsg = "ÎπÑÎîîÏò§ OFF";
			else this.videoMsg = "ÎπÑÎîîÏò§ ON";
			// if(this.video == 'ÎπÑÎîîÏò§ ON') this.video = 'ÎπÑÎîîÏò§ OFF';
			// else this.video = 'ÎπÑÎîîÏò§ ON';
			this.publisher.publishVideo(this.videoEnabled);
		},

		muteAudio() {
			this.audioEnabled = !this.audioEnabled;
			this.audio = !this.audio;
			if(this.audio == true) this.audioMsg = "ÎßàÏù¥ÌÅ¨ OFF";
			else this.audioMsg = "ÎßàÏù¥ÌÅ¨ ON";
			// if(this.audioMsg == 'ÎßàÏù¥ÌÅ¨ ON') this.audioMsg = 'ÎßàÏù¥ÌÅ¨ OFF';
			// else this.audioMsg = 'ÎßàÏù¥ÌÅ¨ ON';
			// if(this.mic == 'mic-fill') this.mic = 'mic-mute-fill';
			// else this.mic = 'mic-fill';
			this.publisher.publishAudio(this.audioEnabled);
		},
		
		updateMainVideoStreamManager (stream) {
			if (this.mainStreamManager === stream) return;
			this.mainStreamManager = stream;
		},

		/**
		 * --------------------------
		 * SERVER-SIDE RESPONSIBILITY
		 * --------------------------
		 * These methods retrieve the mandatory user token from OpenVidu Server.
		 * This behavior MUST BE IN YOUR SERVER-SIDE IN PRODUCTION (by using
		 * the API REST, openvidu-java-client or openvidu-node-client):
		 *   1) Initialize a Session in OpenVidu Server	(POST /openvidu/api/sessions)
		 *   2) Create a Connection in OpenVidu Server (POST /openvidu/api/sessions/<SESSION_ID>/connection)
		 *   3) The Connection.token must be consumed in Session.connect() method
		 */

		getToken (mySessionId) {
			return this.createSession(mySessionId).then(sessionId => this.createToken(sessionId));
		},

		// See https://docs.openvidu.io/en/stable/reference-docs/REST-API/#post-session
		createSession (sessionId) {
			return new Promise((resolve, reject) => {
				axios
					.post(`${OPENVIDU_SERVER_URL}/openvidu/api/sessions`, JSON.stringify({
						customSessionId: sessionId,
					}), {
						auth: {
							username: 'OPENVIDUAPP',
							password: OPENVIDU_SERVER_SECRET,
						},
					})
					.then(response => response.data)
					.then(data => resolve(data.id))
					.catch(error => {
						if (error.response.status === 409) {
							resolve(sessionId);
						} else {
							console.warn(`No connection to OpenVidu Server. This may be a certificate error at ${OPENVIDU_SERVER_URL}`);
							if (window.confirm(`No connection to OpenVidu Server. This may be a certificate error at ${OPENVIDU_SERVER_URL}\n\nClick OK to navigate and accept it. If no certificate warning is shown, then check that your OpenVidu Server is up and running at "${OPENVIDU_SERVER_URL}"`)) {
								location.assign(`${OPENVIDU_SERVER_URL}/accept-certificate`);
							}
							reject(error.response);
						}
					});
			});
		},

		// See https://docs.openvidu.io/en/stable/reference-docs/REST-API/#post-connection
		createToken (sessionId) {
			return new Promise((resolve, reject) => {
				axios
					.post(`${OPENVIDU_SERVER_URL}/openvidu/api/sessions/${sessionId}/connection`, {}, {
						auth: {
							username: 'OPENVIDUAPP',
							password: OPENVIDU_SERVER_SECRET,
						},
					})
					.then(response => response.data)
					.then(data => resolve(data.token))
					.catch(error => reject(error.response));
			});
		},	
		
	},
	
	watch: {
		messages() {
			this.$nextTick(() => {
				let msg = this.$refs.messages;

				msg.scrollTo({ top: msg.scrollHeight, behavior: 'smooth' });
      });
		},

	},
}
</script>
