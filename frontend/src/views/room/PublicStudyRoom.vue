d<template>
	<div id="main">
		<div id="main-container">
			<div id="session-aside-left" v-if="session">
				<p><img src="@/assets/img/openvidu/asideimg01.png" class="sideMenuImg" alt="settings"></p>
			</div>
			<div id="session-aside-right" v-if="session">
				<div class="participant">
					<div class="right_label">
						<span>Ï∞∏Í∞ÄÏûê</span>
					</div>
					<div class="participant_list"> <!-- Ï∞∏Í∞ÄÏûê Î¶¨Ïä§Ìä∏ ÌôîÎ©¥ -->
						<user-list :stream-manager="publisher"/>
						<user-list v-for="sub in subscribers" :key="sub.stream.connection.connectionId" :stream-manager="sub"/>
					</div>
				</div>

				<!-- Ï±ÑÌåÖ Í∏∞Îä• ÏãúÏûë -->
				<!-- <p @click="showChat">Ï±ÑÌåÖ</p> -->
					<!-- <div class="chat" v-show="isChatVisible"> -->
				<div class="user_chat">
					<div class="right_label">
						<span>Ï±ÑÌåÖ</span>
					</div>
					<div class="chat">
						<div class="messages" v-html="messages" ref="messages">
							<!-- <div class="messageLoop" v-for="(message, idx) in messages" :key="idx"> -->
								<!-- <div class="text-left" >{{ userId }} ÎãòÏùò Î©îÏãúÏßÄ:</div> -->
								<!-- <div class="text-left message__bubble">{{ message }}</div> -->
							<!-- </div> -->
						</div>

						<form class="chatFooter" onsubmit="return false">
							<input class="chat_input" id="msg" type="text" autocomplete="off" placeholder="Î©îÏÑ∏ÏßÄÎ•º ÏûÖÎ†•ÌïòÏÑ∏Ïöî.">
							<button id="submitBtn" type="submit" @click="sendMessage()">Enter</button>
						</form>
					</div>
				</div>
				<!-- Ï±ÑÌåÖ Í∏∞Îä• ÎÅù -->

			</div>
			<div id="session-center" style="height:100%;">
				<div id="session" v-if="session">
					<div id="session-header" class="d-flex">
						<h1 id="session-title">{{ this.roomName }}</h1> <!-- Î∞© Ï†úÎ™© -->
					</div>
					
					<div>
						<!--
						<div id="main-video" class="col-md-6"> Î≥∏Ïù∏ ÌôîÎ©¥ 
							<user-video :stream-manager="mainStreamManager"/>
						</div>
						-->
						<div id="video-container" class="d-flex flex-wrap"> <!-- Ï∞∏Í∞ÄÏûê ÌôîÎ©¥ -->
							<user-video :stream-manager="publisher" @click.native="updateMainVideoStreamManager(publisher)"/>
							<user-video v-for="sub in subscribers" :key="sub.stream.connection.connectionId" :stream-manager="sub" @click.native="updateMainVideoStreamManager(sub)"/>
						</div>
					</div>
				</div>

				<div id="sesion-footer-wrap" class="d-flex justify-content-center" style="width: 70%; height:10%;">
					<div id="session-footer" v-if="session">
						<div class="session-footer_btn d-flex justify-content-center">
							<!-- microphone Î≤ÑÌäº ÏÑ§Ï†ï -->
							<div v-if="audio === true" class="buttomMenu">
								
								<button class="btn btn-large btn-default footerBtn" type="button" id="buttonLeaveSession" @click="muteAudio()">
									<b-icon icon="mic-fill" class="buttomMenuIcon" aria-hidden="true"></b-icon>
									<span class="footerBtnText">{{ audioMsg }}</span>
								</button> <!-- ÎßàÏù¥ÌÅ¨ on/off Î≤ÑÌäº -->
							</div>
							<div v-else class="roomFun buttomMenu">
								<button class="btn btn-large btn-default footerBtn" type="button" id="buttonLeaveSession" @click="muteAudio()">
									<b-icon icon="mic-mute-fill" class="buttomMenuIcon" aria-hidden="true"></b-icon>
									<span class="footerBtnText">{{ audioMsg }}</span>
								</button><!-- ÎßàÏù¥ÌÅ¨ on/off Î≤ÑÌäº -->
							</div>	

							<!-- video Î≤ÑÌäº ÏÑ§Ï†ï -->
							<div v-if="video === true" class="buttomMenu">
								<!-- <input class="btn btn-large btn-default footerBtn" type="button" id="buttonLeaveSession" :value="video" @click="muteVideo()"> ÎπÑÎîîÏò§ on/off Î≤ÑÌäº -->
								<button class="btn btn-large btn-default footerBtn" type="button" id="buttonLeaveSession" @click="muteVideo()"> 
									<b-icon icon="camera-video-fill" class="buttomMenuIcon" aria-hidden="true"></b-icon>
									<span class="footerBtnText">{{ videoMsg }}</span>
								</button>
							</div>
							<div v-else class="roomFun buttomMenu">
								<button class="btn btn-large btn-default footerBtn" type="button" id="buttonLeaveSession" @click="muteVideo()"> 
									<b-icon icon="camera-video-off-fill" class="buttomMenuIcon" aria-hidden="true"></b-icon>
									<span class="footerBtnText">{{ videoMsg }}</span>
								</button>
							</div>

							<!-- ÎÇòÍ∞ÄÍ∏∞ Î≤ÑÌäº ÏÑ§Ï†ï -->
							<div class="buttomMenu">
								<button class="btn btn-large btn-default footerBtn" type="button" id="buttonLeaveSession" @click="leaveSession">
									<b-icon icon="door-open-fill" class="buttomMenuIcon" aria-hidden="true"></b-icon>
									<span class="footerBtnText">ÎÇòÍ∞ÄÍ∏∞</span>
								</button> <!-- ÎÇòÍ∞ÄÍ∏∞ Î≤ÑÌäº -->
							</div>
						</div>	
					</div>
				</div>
			</div>
		</div> <!-- #container -->
		
	</div>
</template>
<style scoped>

</style>
<script>
import "@/assets/style/style.css";
import "@/assets/style/PrivateStudyRoom/room.css"
import axios from 'axios';
import http from "@/util/http-common.js";
import { OpenVidu } from 'openvidu-browser';
import UserVideo from '@/components/openvidu/UserVideo';
import UserList from '@/components/openvidu/UserList';
import jwt_decode from "jwt-decode";

import { mapState } from "vuex";

axios.defaults.headers.post['Content-Type'] = 'application/json';

const OPENVIDU_SERVER_URL = "https://i6e103.p.ssafy.io:8084";
const OPENVIDU_SERVER_SECRET = "ssafy1234";

export default {
	name: 'App',

	components: {
		UserVideo,
		UserList,
	},
	metaInfo: {
		// title ÏûÖÎ†•ÌïòÍ∏∞
		title: 'COSMOS',
		// link tag ÏûÖÎ†•ÌïòÍ∏∞
		link: [{rel: "stylesheet", href: 'https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css'}],
		// meta tag ÏûÖÎ†•ÌïòÍ∏∞
		meta: [
		{ charset: 'utf-8' },
		{ name: 'viewport', content: 'width=device-width, initial-scale=1' },
		{ vmid: "description", name: "description", content: 'description' }
		//vmid ‚Üë Î©îÌÉÄ ÌÉúÍ∑∏Î•º Í≥†Ïú†ÌïòÍ≤å ÎßåÎì§Ïñ¥Ï§ÄÎã§.
		]
  },
	data () {
		return {
			// ÌôîÎ©¥ Í≥µÏú†
			// OVForScreenShare: undefined,
			// sessionForScreenShare: undefined,
			sharingPublisher: undefined,
			sharing:true,
			OV: undefined,
			session: undefined,
			mainStreamManager: undefined,
			publisher: undefined,
			subscribers: [],
			mySessionId: 'SessionA',
			myUserName: 'Participant' + Math.floor(Math.random() * 100),
			audioEnabled: true,
			videoEnabled: true,
			audio: true,
			video: true,
			audioMsg: 'ÎßàÏù¥ÌÅ¨ ON',
			videoMsg: 'ÎπÑÎîîÏò§ ON',
			messages: '',
			userId: '',
			isChatVisible: false,


			// ÌÉÄÏù¥Î®∏
			// timer: null,
			// inputHour: null,
			// inputMin: null,
			// inputSec: null,
			// time: 0,
			// resetButton: false,
			// edit: false,

			// Í∂åÌïú Ïó¨Î∂Ä
			userAuthority: false,
		}
	},
	computed:{
		...mapState(["roomName", "roomUrl", "participant", "roomStudyNo", "studyMembers"]),

		// totalTime() {
		// 	return Number(this.inputHour * 3600) + Number(this.inputMin * 60) + Number(this.inputSec)
		// },
		// hours(){
		// 	const hours = Math.floor(this.time / 3600)
		// 	return this.padTime(hours)
		// },
		// minutes() {
		// 	// const minutes = Math.floor(this.time / 60)
		// 	const minutes = Math.floor((this.time - (this.hours * 3600)) / 60)
		// 	return this.padTime(minutes)
		// },
		// seconds() {
		// 	const seconds = this.time - ((this.hours * 3600) + (this.minutes * 60))
		// 	return this.padTime(seconds)
		// },
	},
	created(){
		// Í∂åÌïú Ïó¨Î∂Ä ÌôïÏù∏
		http({
            method: 'GET',
            url: `/user/leader`,
            headers: this.getUserToken(),
			params: {study_no: this.roomStudyNo},
			// params: {study_no: 25},
          })
        .then((res) => {
            this.userAuthority = res.data.authority;
			// console.log("üòâüòâ")
			// console.log(res);
          })
          .catch(err => {
            console.log(err)
		});  

		this.mySessionId = this.roomUrl;
		this.myUserName = this.participant;
		this.joinSession();
		
		// console.log("üòÄüòÄüòÄüòÄüòÄ")
		// console.log(this.mySessionId)

		// ÌÖçÏä§Ìä∏ Ï±ÑÌåÖÏóêÏÑú ÏÇ¨Ïö©ÌïòÍ∏∞ÏúÑÌïú Ïú†Ï†Ä ÏïÑÏù¥Îîî(ÏûÑÏãú)
		this.userId = jwt_decode(localStorage.getItem("jwt")).sub;
		console.log(">>>>>>>>>>>>>>>>>>>> userId : ", this.userId);

		// ÏÉÅÎ≤åÏ†ê ÏúÑÌïú Ïä§ÌÑ∞ÎîîÎ©§Î≤Ñ Î∂àÎü¨Ïò§Í∏∞
		this.getStudyMembers()
	},
	methods: {
		getUserToken(){
			const token = localStorage.getItem('jwt')
			const header = {
				Authorization: `Bearer ${token}`
			}
			return header
		},
		// startTimer() {
		// 	if(!this.inputHour && !this.inputMin && !this.inputSec){
		// 		alert("ÏãúÍ∞ÑÏùÑ ÏÑ§Ï†ïÌï¥Ï£ºÏÑ∏Ïöî.")
		// 	} else{
		// 	//1000ms = 1 second
		// 	this.timer = setInterval(() => this.countdown(), 1000)
		// 	this.resetButton = true
		// 	this.edit = false
		// 	}
		// },
		// stopTimer: function() {
		// 	clearInterval(this.timer)
		// 	this.timer = null
		// 	this.resetButton = true
		// },
		// resetTimer: function() {
		// 	// this.time = this.totalTime
		// 	this.time = 0
		// 	clearInterval(this.timer)
		// 	this.timer = null
		// 	this.resetButton = false
		// 	this.inputHour = null
		// 	this.inputMin = null
		// 	this.inputSec = null
		// },
		// editTimer: function() {
		// 	this.edit = !this.edit
		// },
		// padTime: function(time){
		// 	return (time < 10 ? '0' : '') + time
		// },
		// countdown: function() {
		// 	if(this.time>0){
		// 		this.time--
		// 	}else{
		// 		this.resetTimer();
		// 		// alert("ÏãúÍ∞ÑÏù¥ Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§.")
		// 	}
		// },
		// sendTimer(){
		// 	// ÌÉÄÏù¥Î®∏ send
		// 	this.session.signal({
		// 		data: this.time,
		// 		to: [],
		// 		type: 'study-timer',
		// 	})
		// 	.then(() => {
		// 		console.log("timer success");
		// 		if(this.time==0){
		// 			alert("ÏãúÍ∞ÑÏù¥ Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§.")
		// 		}
		// 	})
		// 	.catch(error => {
		// 		console.error(error);
		// 	})
		// },

		getToken_info(){
			const token = localStorage.getItem('jwt')
			const header = {
				Authorization: `Bearer ${token}`
			}
      		return header
   		 },

		
		joinSession () {
			// --- Get an OpenVidu object ---
			this.OV = new OpenVidu();

			// --- Init a session ---
			this.session = this.OV.initSession();
		
			// --- Specify the actions when events take place in the session ---

			// On every new Stream received...
			this.session.on('streamCreated', ({ stream }) => {
				const subscriber = this.session.subscribe(stream);
				this.subscribers.push(subscriber);
			});

			// On every Stream destroyed...
			this.session.on('streamDestroyed', ({ stream }) => {
				const index = this.subscribers.indexOf(stream.streamManager, 0);
				if (index >= 0) {
					this.subscribers.splice(index, 1);
				}
			});

			// On every asynchronous exception...
			this.session.on('exception', ({ exception }) => {
				console.warn(exception);
			});

			// Í∞ôÏùÄ session ÎÇ¥ÏóêÏÑú ÌÖçÏä§Ìä∏ Ï±ÑÌåÖÏùÑ ÏúÑÌïú signal
			this.session.on('signal:my-chat', (event) => {
				var message = event.data.split("&$");
				console.log(">>>>>>>>>>>>>> message : ", message);

				if(message == "") {
					this.messages += '';
				} else {
					// console.log(">>>>>>>>>>>>>>>>>>> ", message[0]);
					// this.messages.push(message[0]);
					console.log("Ï†ÄÏû•Îêú : ", this.$store.state.userId, "ÌòÑÏû¨ : ", message[0]);
					if(this.$store.state.userId == message[0]) {
						console.log("ÎÇ¥Í∞Ä Ïì¥ Î©îÏãúÏßÄ");
						this.messages += '<div align="right">' 
									   + 	'<div style="padding: 10px; margin-bottom: 10px; width: 60%; background-color: #fff; border-radius: 10px;">'
									   +  		'<div style="font-weight: 900;">' + message[0] + ' ÎãòÏùò Î©îÏãúÏßÄ: </div>'
									   +  		'<div class="mb-3">' + message[1] + ' </div>'
									   +  	'</div>'
									   + '</div>';
					} else {
						console.log('ÎãàÍ∞Ä Ïì¥ Î©îÏãúÏßÄ');
						this.messages += '<div align="left">' 
									   + 	'<div style="padding: 10px; margin-bottom: 10px; width: 60%; background-color: #6363bf; color: #fff; border-radius: 10px;">'
									   +  	'<div style="font-weight: 900;">' + message[0] + ' ÎãòÏùò Î©îÏãúÏßÄ: </div>'
									   +  	'<div class="mb-3">' + message[1] + ' </div>'
									   +  '</div>';
					}
				}
			});
		
			// --- Connect to the session with a valid user token ---

			// 'getToken' method is simulating what your server-side should do.
			// 'token' parameter should be retrieved and returned by your own backend
			this.getToken(this.mySessionId).then(token => {
				this.session.connect(token, { clientData: this.myUserName })
					.then(() => {

						// --- Get your own camera stream with the desired properties ---
						// console.log("Dasdasdasdasdasdasdasdasdasdasdasdasdqwrqwrqw");
						// console.log(this.session)
						let publisher = this.OV.initPublisher(undefined, {
							audioSource: undefined, // The source of audio. If undefined default microphone
							videoSource: undefined, // The source of video. If undefined default webcam
							publishAudio: true,  	// Whether you want to start publishing with your audio unmuted or not
							publishVideo: true,  	// Whether you want to start publishing with your video enabled or not
							resolution: '640x480',  // The resolution of your video
							frameRate: 30,			// The frame rate of your video
							insertMode: 'APPEND',	// How the video is inserted in the target element 'video-container'
							mirror: false,       	// Whether to mirror your local video or not
						});

						this.mainStreamManager = publisher;
						this.publisher = publisher;

						// --- Publish your stream ---

						this.session.publish(this.publisher);
						console.log("Dasdasdasdasdasdasdasdasdasdasdasdasdqwrqwrqw");
						console.log(this.session)
					})
					.catch(error => {
						console.log('There was an error connecting to the session:', error.code, error.message);
					});
			});

			

			window.addEventListener('beforeunload', this.leaveSession)
		},

		leaveSession () {
			// --- Leave the session by calling 'disconnect' method over the Session object ---
			if (this.session) this.session.disconnect();

			this.session = undefined;
			this.mainStreamManager = undefined;
			this.publisher = undefined;
			this.subscribers = [];
			this.OV = undefined;
			this.OVForScreenShare = undefined;
			this.sharingPublisher = undefined;
			window.removeEventListener('beforeunload', this.leaveSession);
			http({
				method: 'DELETE',
				url: `/publicroom/remove/publicMember`,
				headers: this.getToken_info(),
				params: {publicstudyroom_id: this.mySessionId},
			})
			.then(() => {
				this.$router.push({name:'MainPage'})
			})
			.catch(err => {
				console.log(err)
			});
			
			this.sharing = !this.sharing;
			if (this.sessionForScreenShare) this.sessionForScreenShare.disconnect();
            this.sessionForScreenShare = undefined;
            this.mainStreamManager = undefined;
            this.sharingPublisher = undefined;
            this.OVForScreenShare = undefined;
            window.removeEventListener('beforeunload', this.leaveSessionForScreenSharing);		
			  	
		},

		// ÌÖçÏä§Ìä∏ Ï±ÑÌåÖÏùÑ ÏúÑÌïú Î©îÏÑ∏ÏßÄ Ï†ÑÏÜ°ÌïòÍ∏∞
		sendMessage() {
			var message = document.getElementById("msg").value;
			if(message != "") {
				console.log("message " , message)
				
				
				this.session.signal({
					data: this.myUserName+ "&$" +message,
					to: [],
					type: 'my-chat',
				})
				.then(() => {
					console.log("message sent successfully!!");
					document.getElementById("msg").value = "";
				})
				.catch(error => {
					console.error(error);
				})
			}
		},

		muteVideo() {
			this.videoEnabled = !this.videoEnabled;
			this.video = !this.video;
			if(this.video == true) this.videoMsg = "ÎπÑÎîîÏò§ OFF";
			else this.videoMsg = "ÎπÑÎîîÏò§ ON";
			// if(this.video == 'ÎπÑÎîîÏò§ ON') this.video = 'ÎπÑÎîîÏò§ OFF';
			// else this.video = 'ÎπÑÎîîÏò§ ON';
			this.publisher.publishVideo(this.videoEnabled);
		},

		muteAudio() {
			this.audioEnabled = !this.audioEnabled;
			this.audio = !this.audio;
			if(this.audio == true) this.audioMsg = "ÎßàÏù¥ÌÅ¨ OFF";
			else this.audioMsg = "ÎßàÏù¥ÌÅ¨ ON";
			// if(this.audioMsg == 'ÎßàÏù¥ÌÅ¨ ON') this.audioMsg = 'ÎßàÏù¥ÌÅ¨ OFF';
			// else this.audioMsg = 'ÎßàÏù¥ÌÅ¨ ON';
			// if(this.mic == 'mic-fill') this.mic = 'mic-mute-fill';
			// else this.mic = 'mic-fill';
			this.publisher.publishAudio(this.audioEnabled);
		},
		
		updateMainVideoStreamManager (stream) {
			if (this.mainStreamManager === stream) return;
			this.mainStreamManager = stream;
		},

		/**
		 * --------------------------
		 * SERVER-SIDE RESPONSIBILITY
		 * --------------------------
		 * These methods retrieve the mandatory user token from OpenVidu Server.
		 * This behavior MUST BE IN YOUR SERVER-SIDE IN PRODUCTION (by using
		 * the API REST, openvidu-java-client or openvidu-node-client):
		 *   1) Initialize a Session in OpenVidu Server	(POST /openvidu/api/sessions)
		 *   2) Create a Connection in OpenVidu Server (POST /openvidu/api/sessions/<SESSION_ID>/connection)
		 *   3) The Connection.token must be consumed in Session.connect() method
		 */

		getToken (mySessionId) {
			return this.createSession(mySessionId).then(sessionId => this.createToken(sessionId));
		},

		// See https://docs.openvidu.io/en/stable/reference-docs/REST-API/#post-session
		createSession (sessionId) {
			return new Promise((resolve, reject) => {
				axios
					.post(`${OPENVIDU_SERVER_URL}/openvidu/api/sessions`, JSON.stringify({
						customSessionId: sessionId,
					}), {
						auth: {
							username: 'OPENVIDUAPP',
							password: OPENVIDU_SERVER_SECRET,
						},
					})
					.then(response => response.data)
					.then(data => resolve(data.id))
					.catch(error => {
						if (error.response.status === 409) {
							resolve(sessionId);
						} else {
							console.warn(`No connection to OpenVidu Server. This may be a certificate error at ${OPENVIDU_SERVER_URL}`);
							if (window.confirm(`No connection to OpenVidu Server. This may be a certificate error at ${OPENVIDU_SERVER_URL}\n\nClick OK to navigate and accept it. If no certificate warning is shown, then check that your OpenVidu Server is up and running at "${OPENVIDU_SERVER_URL}"`)) {
								location.assign(`${OPENVIDU_SERVER_URL}/accept-certificate`);
							}
							reject(error.response);
						}
					});
			});
		},

		// See https://docs.openvidu.io/en/stable/reference-docs/REST-API/#post-connection
		createToken (sessionId) {
			return new Promise((resolve, reject) => {
				axios
					.post(`${OPENVIDU_SERVER_URL}/openvidu/api/sessions/${sessionId}/connection`, {}, {
						auth: {
							username: 'OPENVIDUAPP',
							password: OPENVIDU_SERVER_SECRET,
						},
					})
					.then(response => response.data)
					.then(data => resolve(data.token))
					.catch(error => reject(error.response));
			});
		},	
		
	},
	
	watch: {
		messages() {
			this.$nextTick(() => {
				let msg = this.$refs.messages;

				msg.scrollTo({ top: msg.scrollHeight, behavior: 'smooth' });
      		});
		},

		// totalTime() {
      	// 	this.time = this.totalTime
    	// },
		// time(){
		// 	this.sendTimer();
		// },
	},
}
</script>
